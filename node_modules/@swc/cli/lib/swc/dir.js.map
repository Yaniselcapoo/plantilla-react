{"version":3,"sources":["../../src/swc/dir.ts"],"sourcesContent":["import slash from \"slash\";\nimport { existsSync, promises } from \"fs\";\nimport { dirname, relative, join } from \"path\";\nimport { CompileStatus } from \"./constants\";\nimport { CliOptions } from \"./options\";\nimport { compile, exists } from \"./util\";\nimport { outputResult } from \"./compile\";\nimport {\n  globSources,\n  isCompilableExtension,\n  splitCompilableAndCopyable,\n  watchSources,\n} from \"./sources\";\n\nimport type { Options } from \"@swc/core\";\n\ndeclare module \"fs\" {\n  namespace promises {\n    /**\n     * For node > 14 we want to use rm instead of rmdir\n     * We need to augment node v12 types\n     */\n    function rm(dir: string, option: object): void;\n  }\n}\n\nconst { mkdir, rmdir, rm, copyFile, unlink } = promises;\n\nconst cwd = process.cwd();\nconst recursive = { recursive: true };\n\n/**\n * Removes the leading directory, including all parent relative paths\n */\nfunction stripComponents(filename: string) {\n  const components = filename.split(\"/\").slice(1);\n  if (!components.length) {\n    return filename;\n  }\n  while (components[0] === \"..\") {\n    components.shift();\n  }\n  return components.join(\"/\");\n}\n\nfunction getDest(filename: string, outDir: string, ext?: string) {\n  const relativePath = slash(relative(cwd, filename));\n  let base = stripComponents(relativePath);\n  if (ext) {\n    base = base.replace(/\\.\\w*$/, ext);\n  }\n  return join(outDir, base);\n}\n\nasync function handleCompile(\n  filename: string,\n  outDir: string,\n  sync: boolean,\n  swcOptions: Options\n) {\n  const dest = getDest(filename, outDir, \".js\");\n  const sourceFileName = slash(relative(dirname(dest), filename));\n\n  const options = { ...swcOptions, sourceFileName };\n\n  const result = await compile(filename, options, sync, dest);\n\n  if (result) {\n    await outputResult(result, filename, dest, options);\n    return CompileStatus.Compiled;\n  } else {\n    return CompileStatus.Omitted;\n  }\n}\n\nasync function handleCopy(filename: string, outDir: string) {\n  const dest = getDest(filename, outDir);\n  const dir = dirname(dest);\n\n  await mkdir(dir, recursive);\n  await copyFile(filename, dest);\n\n  return CompileStatus.Copied;\n}\n\nasync function beforeStartCompilation(cliOptions: CliOptions) {\n  const { outDir, deleteDirOnStart } = cliOptions;\n\n  if (deleteDirOnStart) {\n    const exists = await existsSync(outDir);\n    if (exists) {\n      rm ? await rm(outDir, recursive) : await rmdir(outDir, recursive);\n    }\n  }\n}\n\nasync function initialCompilation(cliOptions: CliOptions, swcOptions: Options) {\n  const {\n    includeDotfiles,\n    filenames,\n    copyFiles,\n    extensions,\n    outDir,\n    sync,\n    quiet,\n    watch,\n    only,\n    ignore,\n  } = cliOptions;\n\n  const results = new Map<string, CompileStatus>();\n\n  const start = process.hrtime();\n  const sourceFiles = await globSources(\n    filenames,\n    only,\n    ignore,\n    includeDotfiles\n  );\n  const [compilable, copyable] = splitCompilableAndCopyable(\n    sourceFiles,\n    extensions,\n    copyFiles\n  );\n\n  if (sync) {\n    for (const filename of compilable) {\n      try {\n        const result = await handleCompile(filename, outDir, sync, swcOptions);\n        results.set(filename, result);\n      } catch (err: any) {\n        console.error(err.message);\n        results.set(filename, CompileStatus.Failed);\n      }\n    }\n    for (const filename of copyable) {\n      try {\n        const result = await handleCopy(filename, outDir);\n        results.set(filename, result);\n      } catch (err: any) {\n        console.error(err.message);\n        results.set(filename, CompileStatus.Failed);\n      }\n    }\n  } else {\n    await Promise.all([\n      Promise.allSettled(\n        compilable.map(file =>\n          handleCompile(file, outDir, sync, swcOptions).catch(err => {\n            console.error(err.message);\n            throw err;\n          })\n        )\n      ),\n      Promise.allSettled(copyable.map(file => handleCopy(file, outDir))),\n    ]).then(([compiled, copied]) => {\n      compiled.forEach((result, index) => {\n        const filename = compilable[index];\n        if (result.status === \"fulfilled\") {\n          results.set(filename, result.value);\n        } else {\n          results.set(filename, CompileStatus.Failed);\n        }\n      });\n\n      copied.forEach((result, index) => {\n        const filename = copyable[index];\n        if (result.status === \"fulfilled\") {\n          results.set(filename, result.value);\n        } else {\n          results.set(filename, CompileStatus.Failed);\n        }\n      });\n    });\n  }\n  const end = process.hrtime(start);\n\n  let failed = 0;\n  let compiled = 0;\n  let copied = 0;\n  for (let [_, status] of results) {\n    switch (status) {\n      case CompileStatus.Compiled:\n        compiled += 1;\n        break;\n      case CompileStatus.Failed:\n        failed += 1;\n        break;\n      case CompileStatus.Copied:\n        copied += 1;\n        break;\n    }\n  }\n\n  if (!quiet && compiled + copied) {\n    let message = \"\";\n    if (compiled) {\n      message += `Successfully compiled: ${compiled} ${\n        compiled > 1 ? \"files\" : \"file\"\n      }`;\n    }\n    if (compiled && copied) {\n      message += \", \";\n    }\n    if (copied) {\n      message += `copied ${copied} ${copied > 1 ? \"files\" : \"file\"}`;\n    }\n    message += ` with swc (%dms)`;\n\n    console.log(message, (end[1] / 1000000).toFixed(2));\n  }\n\n  if (failed) {\n    console.log(\n      `Failed to compile ${failed} ${failed !== 1 ? \"files\" : \"file\"} with swc.`\n    );\n    if (!watch) {\n      const files = Array.from(results.entries())\n        .filter(([, status]) => status === CompileStatus.Failed)\n        .map(([filename, _]) => filename)\n        .join(\"\\n\");\n      throw new Error(`Failed to compile:\\n${files}`);\n    }\n  }\n}\n\nasync function watchCompilation(cliOptions: CliOptions, swcOptions: Options) {\n  const {\n    includeDotfiles,\n    filenames,\n    copyFiles,\n    extensions,\n    outDir,\n    quiet,\n    sync,\n  } = cliOptions;\n\n  const watcher = await watchSources(filenames, includeDotfiles);\n  watcher.on(\"ready\", () => {\n    if (!quiet) {\n      console.info(\"Watching for file changes.\");\n    }\n  });\n  watcher.on(\"unlink\", async filename => {\n    try {\n      if (isCompilableExtension(filename, extensions)) {\n        await unlink(getDest(filename, outDir, \".js\"));\n        const sourcemapPath = getDest(filename, outDir, \".js.map\");\n        const sourcemapExists = await exists(sourcemapPath);\n        if (sourcemapExists) {\n          await unlink(sourcemapPath);\n        }\n      } else if (copyFiles) {\n        await unlink(getDest(filename, outDir));\n      }\n    } catch (err: any) {\n      if (err.code !== \"ENOENT\") {\n        console.error(err.stack);\n      }\n    }\n  });\n  for (const type of [\"add\", \"change\"]) {\n    watcher.on(type, async filename => {\n      if (isCompilableExtension(filename, extensions)) {\n        try {\n          const start = process.hrtime();\n          const result = await handleCompile(\n            filename,\n            outDir,\n            sync,\n            swcOptions\n          );\n          if (!quiet && result === CompileStatus.Compiled) {\n            const end = process.hrtime(start);\n            console.log(\n              `Successfully compiled ${filename} with swc (%dms)`,\n              (end[1] / 1000000).toFixed(2)\n            );\n          }\n        } catch (err: any) {\n          console.error(err.message);\n        }\n      } else if (copyFiles) {\n        try {\n          const start = process.hrtime();\n          const result = await handleCopy(filename, outDir);\n          if (!quiet && result === CompileStatus.Copied) {\n            const end = process.hrtime(start);\n            console.log(\n              `Successfully copied ${filename} with swc (%dms)`,\n              (end[1] / 1000000).toFixed(2)\n            );\n          }\n        } catch (err: any) {\n          console.error(`Failed to copy ${filename}`);\n          console.error(err.message);\n        }\n      }\n    });\n  }\n}\n\nexport default async function dir({\n  cliOptions,\n  swcOptions,\n}: {\n  cliOptions: CliOptions;\n  swcOptions: Options;\n}) {\n  const { watch } = cliOptions;\n\n  await beforeStartCompilation(cliOptions);\n  await initialCompilation(cliOptions, swcOptions);\n\n  if (watch) {\n    await watchCompilation(cliOptions, swcOptions);\n  }\n}\n"],"names":["dir","mkdir","rmdir","rm","copyFile","unlink","promises","cwd","process","recursive","stripComponents","filename","components","split","slice","length","shift","join","getDest","outDir","ext","relativePath","slash","relative","base","replace","handleCompile","sync","swcOptions","dest","sourceFileName","dirname","options","result","compile","outputResult","CompileStatus","Compiled","Omitted","handleCopy","Copied","beforeStartCompilation","cliOptions","deleteDirOnStart","exists","existsSync","initialCompilation","includeDotfiles","filenames","copyFiles","extensions","quiet","watch","only","ignore","results","Map","start","hrtime","sourceFiles","globSources","compilable","copyable","splitCompilableAndCopyable","set","err","console","error","message","Failed","Promise","all","allSettled","map","file","catch","then","compiled","copied","forEach","index","status","value","end","failed","_","log","toFixed","files","Array","from","entries","filter","Error","watchCompilation","watcher","watchSources","on","info","isCompilableExtension","sourcemapPath","sourcemapExists","code","stack","type"],"mappings":"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"}